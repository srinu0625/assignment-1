# Iterate over each row of the daily DataFrame (data1)
for index1, row1 in data1.iterrows():
    # Check if the row has valid data
    if pd.notna(row1[time_column_name]) and pd.notna(row1[high_column_name]) and pd.notna(row1[low_column_name]):
        # Extract the current date from the daily data
        current_date1 = row1[time_column_name].split()[0]

        # Iterate over each row of the hourly DataFrame (data2)
        for index2, row2 in data2.iterrows():
            # Check if the row has valid data
            if pd.notna(row2[time_column_name]) and pd.notna(row2[high_column_name]) and pd.notna(row2[low_column_name]):
                # Extract the current date from the hourly data
                current_date2 = row2[time_column_name].split()[0]

                # If the hourly data date matches the daily data date
                if current_date2 == current_date1:
                    try:
                        # Extracting current and previous values for high and low from data1
                        current_time1 = row1[time_column_name]
                        current_high1 = float(row1[high_column_name])
                        previous_high1 = float(data1.at[index1 - 1, high_column_name]) if index1 > 0 else 0
                        current_low1 = float(row1[low_column_name])
                        previous_low1 = float(data1.at[index1 - 1, low_column_name]) if index1 > 0 else 0

                        # Extracting current and previous values for high and low from data2
                        current_time2 = row2[time_column_name]
                        current_high2 = float(row2[high_column_name])
                        previous_high2 = float(data2.at[index2 - 1, high_column_name]) if index2 > 1 else 0
                        current_low2 = float(row2[low_column_name])
                        previous_low2 = float(data2.at[index2 - 1, low_column_name]) if index2 > 1 else 0

                        # Case 1 for data1
                        if current_high1 > previous_high1:
                            temp_high1 = current_high1
                            local_low1 = temp_low1

                        if current_low1 < previous_low1:
                            temp_low1 = current_low1
                            local_high1 = temp_high1

                        if current_high1 > previous_high1 and current_low1 < previous_low1:
                            local_high1 = temp_high1
                            local_low1 = temp_low1
                            
                        # Capture data for data1
                        data1_log = {
                            'Type': 'N/A',
                            'Time': current_time1,
                            'Current High1': current_high1,
                            'Previous High1': previous_high1,
                            'Local High1': local_high1,
                            'Current Low1': current_low1,
                            'Previous Low1': previous_low1,
                            'Local Low1': local_low1
                        }

                        # Capture data for data2
                        data2_log = {
                            'Type': 'N/A',
                            'Time': current_time2,
                            'Current High2': current_high2,
                            'Previous High2': previous_high2,
                            'Local High2': local_high2,
                            'Current Low2': current_low2,
                            'Previous Low2': previous_low2,
                            'Local Low2': local_low2
                        }

                        # Bullish entry
                        if local_high1 > 0:
                            if (current_high1 > local_high1) and (local_low1 >= local_low2) and not bear and not flag:
                                loss_for_trade = abs(local_high1 - current_low1 + (tick_val * 4)) * contract_size
                                if loss_for_trade > risk:
                                    num_of_lots = 1
                                    continue
                                else:
                                    num_of_lots = math.floor(risk / loss_for_trade)
                                    if num_of_lots >= max_num_lots:
                                        num_of_lots = 5
                                    entry_price = local_high1 + (tick_val * 2)
                                    exit_price = current_low1 - (tick_val * 2)
                                    print("\033[32m<------ LONG ENTRY ------>(CH1 > LH1) AND (LL1 >= LL2)\033[0m")
                                    print("       ENTRY PRICE  = ", entry_price)
                                    print("        num_of_lots = ", round(num_of_lots))
                                    print("     loss_for_trade = ", round(loss_for_trade))
                                    print("----------------------------------------------------------")
                                    bull = True
                                    flag = True

                                    # Record the trade entry
                                    trade_entries.append({
                                        'Type': 'Long',
                                        'Entry Time': current_time1,
                                        'Entry Price': entry_price,
                                        'Local High': local_high1,
                                        'Local Low': local_low1,
                                        'Prev  High': previous_high1,
                                        'Prev  Low': previous_low1,
                                        'Current High': current_high1,
                                        'Current Low': current_low1,
                                        'Data1 Log': str(data1_log),
                                        'Data2 Log': str(data2_log)
                                    })

                                    continue
                        
                        # Updating exit price
                        if bull and current_low1 > exit_price:
                            exit_price = current_low1 

                        # Bullish Exit
                        if current_low1 < exit_price and bull and flag:
                            num_of_trades += 1
                            bull = False
                            flag = False

                            # Calculate P&L
                            pnl = (exit_price - entry_price) * num_of_lots * contract_size
                            TOTAL_P_L += pnl
                            total_long_pnl += pnl
                            integer_pnl = float(pnl)  # Extract the integer part of the P&L

                            # Declaring max loss and max profit
                            max_profit = max(max_profit, pnl)
                            max_loss = min(max_loss, pnl)

                            # Check if integer part of P&L is positive or negative and set color accordingly
                            if integer_pnl >= 0:
                                pnl_color = "\033[32m"  # Green color
                            else:
                                pnl_color = "\033[31m"  # Red color

                            # Add to total positive or negative P&L based on the result
                            if pnl >= 0:
                                positive_pnl += pnl
                                total_positive_trades += 1
                            else:
                                negative_pnl += pnl
                                total_negative_trades += 1

                            print("\033[32m<------ LONG EXIT ------>(LL1 >\033[0m")
                            print("         EXIT PRICE = ", exit_price)
                            print("        num
